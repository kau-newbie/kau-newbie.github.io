---
layout: post
title:  "[BookReport]독후감-객체지향 사고 프로세스"
author: kau-newbie
categories: [ OOP, bookreport ]
image: 
---


## **객체지향 사고 프로세스**The Object-Oriented Thought Process, Matt Weisfeld 를 읽고.


우연히 알라딘 중고서점에서 눈에 띄는 책을 발견했다. <<객체지향 사고 프로세스, 5th>>란 제목이었다.

마침, 학교에서 객체지향 언어를 배우는 수업이라곤 열리지 않아 골머리를 앓던 중이었기에, 얼른 집어들었다.

객체지향에 대한 저자의 생각과 예시, 그리고 번역가의 '엄밀한' 용어 번역이 눈에 띄는 책이었다.

...

그래서, 객체지향이 뭔데?

**| 객체지향**

객체지향에 대해서 저자는 사전같은 정의를 내려주진 않는다. 다만, 점차 진화적으로 발전해온 개념이며(나는 이걸 어느날 갑자기 튀어나온 개념이 아니라고 해석했다.), 캡슐화, 은닉화, 상속과 합성이 가능하며, 다형성을 갖는 프로그래밍의 한 방식이라고 말한다.

먼저, 캡슐화와 은닉화를 얘기하자면,

객체는 기본적으로 데이터와 행동이 함께 정의돼있다. 단일 객체로서, 데이터와 행동을 함께 포장(캡슐화!)한 것이다. 

여기서 사용자는(개발자일 수도 있고, 정말 제품을 사용하는 고객일 수도 있고. 주로 개발자를 가리킨다.) 

이 객체에 대해 내부 동작(구현부)는 알지 못한채로, 외부로 드러나있는 인터페이스(public으로 지정된 행동들)를 통해 데이터에 접근할 수 있다.(은닉화!) 
> 여기서 인터페이스는 자동차의 기어봉이나, 핸들, 계기판 등을 생각하면 된다. 자동차 차체 내부에서 동작하는 복잡한 기계 장치들의 실시간 상황을 살피거나 조작할 수 있는 부분들이다.

나는 이런 방식이 verilog hdl로 하드웨어를 설계할 때, '뭐든지 모듈로 보는 방식'과 유사하다고 생각했다. 인풋과 아웃풋이라는, 외부에서 접근가능한 방식만이 겉으로 드러날 뿐이고, 내부 구조는 모른다. 그냥 어떤 인풋을 넣으면, 어떤 아웃풋이 나오는 커다란 블랙박스(모듈)일 뿐이다.

이런 모듈성이 굉장히 중요한 이유가, 객체지향은 개발 단계에서의 편의를 위해 기존 절차지향의 최적화를 포기한 trade-off 이기 때문이다.

내가 해석하기로는, 좀 더 개발자의, 사람의 편의를 위한 개발 방식이었다.

왜냐하면, 어떤 api, 인터페이스(이하 IF)를 지정해놓고 나면, 구현은 자유에 맡기기 때문이다. IF의 기능약속만 지키면 아무런 상관이 없다. 해당 모듈은 붙였다 떼도 된다. 

사람의 입장에서 절차지향적으로 대규모 코드를 짜고 나면, 여기저기 왔다갔다 읽으려고 하니 이해하기가 어렵지만,

어떤 추상적인 기능을 하는 객체로서 (모듈) 정의하고 나면, 훨씬 이해하기 쉬워진다. 다시 한 번 강조하지만, 내부 구현은 누구에게나 자유롭게 맡겨도 된다. 약속들만 지킨다면.

이런 방식(추상적인 기능과 IF 부분만 약속하고, 구현은 맡기는 것)은 이미 곳곳에서 녹아있던 방식같다. 
- OS들이 제공하는 API를 통해 구현한 다양한 컴파일러들의 API 함수라던지, 
- 당장 자동차만 생각해도 우리는 내부구현이 어떻게 돼있는지 모른다. 다만, 계기판과, 기어봉, 핸들과 시동(키 또는 버튼) 등으로 자동차를 조작할 뿐이다. 

(will be updated soon)