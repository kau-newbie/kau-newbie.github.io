---
layout: post
title:  "[BookReport] 객체지향 사고 프로세스"
author: kau-newbie
categories: [ OOP, bookreport ]
image: 
---


## **객체지향 사고 프로세스**The Object-Oriented Thought Process, Matt Weisfeld 를 읽고.


우연히 알라딘 중고서점에서 눈에 띄는 책을 발견했다. <<객체지향 사고 프로세스, 5th>>란 제목이었다.

마침, 학교에서 객체지향 언어를 배우는 수업이라곤 열리지 않아 골머리를 앓던 중이었기에, 얼른 집어들었다.

객체지향에 대한 저자의 생각과 예시, 그리고 번역가의 '엄밀한' 용어 번역이 눈에 띄는 책이었다.


<br><br>


### 객체지향 개념 소개

**| 객체**

객체(Object)는 

- 이 책에 따르면, 데이터들(attribute)과 행위들(methods, properties)로 이루어진 객체지향 프로그램의 코드 블록이다. 객체지향 프로그램은 이런 객체들로 이루어진다. 이를테면, 강아지라는 객체가 있을 수 있다. 강아지는 color라는 색깔 특성을 가질 수 있고(attribute), bark()라는 행위를 가질 수 있다.(properties).

- 이 책의 옮긴이에 따르면, 우리가 흔히 '클래스', '구현체', '인스턴스'라고 부르는 것들을 통칭하는 개념이다. '외부의 객관화된 대상'이라고도 할 수 있겠다.

+(여기서 옮긴이는 용어를 엄밀히 구분하는데, 클래스는 객체의 설계도(개념이라고 표현하면 어떨까 싶다.), 구현체는 메모리에 올라가는(/갈) 클래스의 코드를, 마지막으로 인스턴스는 코드 내에서 new 등의 키워드로 생성된 하나의 클래스 사례체를 의미한다.)

- 개인적으로 궁금해 따로 제미나이에게 물어보니 근대 인식론에 따른, 주체(subject)와 구분되는 그 외부의 모든 것들을 의미한다.

왜 객체라는 개념이 쓰이게 됐는지도 찾아봤다. 마구잡이로 현실 세계의 복잡한 현상을 코딩하지 않고, 특정한 경계를 가진 독립적인 단위들로 나누어 정의한 뒤 정의하면 '사람이' 이해하기 쉽기 때문이랬다. 

즉, "어떤 절차로 처리할 것인가"에서, "어떤 대상들이 존재하고, 그들이 서로 어떻게 상호작용하는가"의 관점으로 바꾼 것이다.

이렇게 하나의 구분된 '객체' 단위로 나눌 때에는 '캡슐화(Encapsulation)' 덕분이라고 한다.
> 이 캡슐화는 네트워크를 배울 때를 떠올리면 쉬웠다. OSI Layer나 TCP/IP suite를 생각하면, 다른 계층의 프로토콜은 신경쓰지 않고, 오직 내 계층에서 무슨 프로토콜을 쓸지만 생각한다. 그리고 정해진 다음 계층(layer)으로 패킷을 전달한다.

그래서, 객체지향이 뭔데?

**| 객체지향**

객체지향에 대해서 저자는 사전같은 정의를 내려주진 않는다. 다만, 점차 진화적으로 발전해온 개념이며(나는 이걸 어느날 갑자기 튀어나온 개념이 아니라고 해석했다.), 캡슐화, 은닉화, 상속과 합성이 가능하며, 다형성을 갖는 프로그래밍의 한 방식이라고 말한다.

먼저, `캡슐화`와 `은닉화`를 얘기하자면,

객체는 기본적으로 데이터와 행동이 함께 정의돼있다. 단일 객체로서, 데이터와 행동을 함께 포장(**캡슐화!**)한 것이다. 

여기서 사용자는(개발자일 수도 있고, 정말 제품을 사용하는 고객일 수도 있고. 주로 개발자를 가리킨다.) 

나는 이런 방식이 verilog hdl로 하드웨어를 설계할 때, '뭐든지 모듈로 보는 방식'과 유사하다고 생각했다. 인풋과 아웃풋이라는, 외부에서 접근가능한 방식만이 겉으로 드러날 뿐이고, 내부 구조는 모른다. 그냥 어떤 인풋을 넣으면, 어떤 아웃풋이 나오는 커다란 블랙박스(모듈)일 뿐이다.

이런 모듈성이 굉장히 중요한 이유가, 객체지향은 개발 단계에서의 편의를 위해 기존 절차지향의 최적화를 포기한 trade-off 이기 때문이다. 

사람의 입장에서 절차지향적으로 대규모 코드를 짜고 나면, 여기저기 왔다갔다 읽으려고 하니 이해하기가 어렵지만, 어떤 추상적인 기능을 하는 객체로서 (모듈) 정의하고 나면, 훨씬 이해하기 쉬워진다. 

이런 방식(추상적인 기능과 IF 부분만 약속하고, 구현은 맡기는 것)은 이미 곳곳에서 녹아있던 방식같다. 
- OS들이 제공하는 API를 통해 구현한 다양한 컴파일러들의 API 함수라던지, 
- 당장 자동차만 생각해도 우리는 내부구현이 어떻게 돼있는지 모른다. 다만, 계기판과, 기어봉, 핸들과 시동(키 또는 버튼) 등으로 자동차를 조작할 뿐이다. 

이 객체에 대해 내부 동작(구현부)는 알지 못한채로, 외부로 드러나있는 인터페이스(public으로 지정된 행동들)를 통해 데이터에 접근할 수 있다.(**은닉화!**) 
> 여기서 인터페이스는 자동차의 기어봉이나, 핸들, 계기판 등을 생각하면 된다. 자동차 차체 내부에서 동작하는 복잡한 기계 장치들의 실시간 상황을 살피거나 조작할 수 있는 부분들이다.

책에서는 "어떤 객체도 다른 객체의 속성을 직접 변경할 수 없다."고 말한다. 만일 은닉화를 위배한다면, (다른 객체가 다른 객체의 속성을 직접 변경한다면) 객체의 성질을 잃어버리고 '주체(subject)'가 돼버릴 것이다. 보통은 setter와 getter로 속성을 변경하고 값을 가져온다고 한다. 이런 방식이 중요한 게, 특히 보안과 테스트 및 유지보수에 꼭 필요하다. 즉, **문제가 생겼을 때, 속성을 변경할 가능성이 있는 모든 코드를 추적할 필요가 없어진다.**

위와 같은 이유가 있어서, 클래스를 설계할 때, 공개 I/F를 설정하고 (반환 값이나 사용법 등), 감출 구현부를 정하는 일이 중요하다고 한다.

생각해보면, 캡스톤 디자인으로 프로그램을 짤 때에도, 하나의 모듈(클래스)에 대한 I/F를 미리 설정해놓지 않아 애먹었던 적이 많다. 

구성원들이 I/F의 반환자를 모르거나, 심지어는 존재조차도 몰랐던 적이 있다. 

미리 I/F에 관한 계약을 위해, interface라는 개념이 생긴 것도 무리가 아닌 것 같다. (interface가 어느정도 다중 상속을 대체하는 기능이 있다고도 들었다.)

추가로, 캡슐화는 일종의 Wrapper로서 쓸 수 있기 때문에, legacy 코드들을 다루는 데에도 쓰인다고 한다.

그 다음으로, `상속`과 `합성`이 있다.

상속은 부모 클래스로부터 자식 클래스가 속성과 행위를 물려받는 시스템이다. (상속을 사용하면 알아서 자식 클래스에서도 부모 클래스의 속성과 행위를 쓸 수 있게 된다. 다양한 언어들에서 extends 등의 키워드를 쓴다.) 객체지향을 소개할 때는 보통 'is-a'관계를 통해 상속을 구분할 수 있다고 소개한다. 
> 예를 들면, 골든리트리버 is Dog이고, Dog is Mammal(포유류)이다. 
> - 따라서, 골든리트리버 클래스는 Dog 클래스의 자식클래스이고, (상속받았고) 
> - Dog 클래스는 Mammal 클래스를 상속받았다.

합성은 다른 객체들로 이루어진 하나의 객체를 만드는 방법이다. 즉, 객체에 다른 객체가 들어있는 형태라고 봐도 되겠다.
> 예를 들면, 컴퓨터라는 객체는 그래픽 카드, 키보드, 마우스 등의 객체로 이루어졌다.
> - 그래픽 카드, 키보드 등을 따로 떼어 손에 쥘 수 있고, 각 객체는 별도의 기능을 한다.

보통 'has-a'관계로 나타낼 수 있으면, 합성이라고 한다.
> 예를 들어, Car 클래스는 Engine 클래스와 Door 클래스 등으로 합성된 클래스이다.
> - Engine is a Car (x). 따라서 상속은 아니다.
> - A Car has a Engine (o). Car은 합성으로 이루어져있다.

나중에 다시 언급하겠지만, 제미나이도 그렇고, 합성을 대부분 선호한다고 한다. 하지만 저자는, 분명히 어느 하나가 좋다/나쁘다를 떠나서 상황에 맞게 잘 쓸 줄 아는 유연한 사고를 강조한다.


<br><br>


### 객체라는 관점에서 생각하는 법

전통적인 



<br><br>


### 객체지향 설계