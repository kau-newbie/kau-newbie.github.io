---
layout: post
title:  "[BookReport] 객체지향 사고 프로세스"
author: kau-newbie
categories: [ OOP, bookreport ]
image: 
---


## **객체지향 사고 프로세스**The Object-Oriented Thought Process, Matt Weisfeld 를 읽고.


우연히 알라딘 중고서점에서 눈에 띄는 책을 발견했다. <<객체지향 사고 프로세스, 5th>>란 제목이었다.

마침, 학교에서 객체지향 언어를 배우는 수업이라곤 열리지 않아 골머리를 앓던 중이었기에, 얼른 집어들었다.

객체지향에 대한 저자의 생각과 예시, 그리고 번역가의 '엄밀한' 용어 번역이 눈에 띄는 책이었다.


<br><br>


### 객체지향 개념 소개

**| 객체**

객체(Object)는 

- 이 책에 따르면, 데이터들(attribute)과 행위들(methods, properties)로 이루어진 객체지향 프로그램의 코드 블록이다. 객체지향 프로그램은 이런 객체들로 이루어진다. 이를테면, 강아지라는 객체가 있을 수 있다. 강아지는 color라는 색깔 특성을 가질 수 있고(attribute), bark()라는 행위를 가질 수 있다.(properties).

- 이 책의 옮긴이에 따르면, 우리가 흔히 '클래스', '구현체', '인스턴스'라고 부르는 것들을 통칭하는 개념이다. '외부의 객관화된 대상'이라고도 할 수 있겠다.

+(여기서 옮긴이는 용어를 엄밀히 구분하는데, 클래스는 객체의 설계도(개념이라고 표현하면 어떨까 싶다.), 구현체는 메모리에 올라가는(/갈) 클래스의 코드를, 마지막으로 인스턴스는 코드 내에서 new 등의 키워드로 생성된 하나의 클래스 사례체를 의미한다.)

- 개인적으로 궁금해 따로 제미나이에게 물어보니 근대 인식론에 따른, 주체(subject)와 구분되는 그 외부의 모든 것들을 의미한다.

왜 객체라는 개념이 쓰이게 됐는지도 찾아봤다. 마구잡이로 현실 세계의 복잡한 현상을 코딩하지 않고, 특정한 경계를 가진 독립적인 단위들로 나누어 정의한 뒤 정의하면 '사람이' 이해하기 쉽기 때문이랬다. 

즉, "어떤 절차로 처리할 것인가"에서, "어떤 대상들이 존재하고, 그들이 서로 어떻게 상호작용하는가"의 관점으로 바꾼 것이다.

이렇게 하나의 구분된 '객체' 단위로 나눌 때에는 '캡슐화(Encapsulation)' 덕분이라고 한다.
> 이 캡슐화는 네트워크를 배울 때를 떠올리면 쉬웠다. OSI Layer나 TCP/IP suite를 생각하면, 다른 계층의 프로토콜은 신경쓰지 않고, 오직 내 계층에서 무슨 프로토콜을 쓸지만 생각한다. 그리고 정해진 다음 계층(layer)으로 패킷을 전달한다.

그래서, 객체지향이 뭔데?

**| 객체지향**

객체지향에 대해서 저자는 사전같은 정의를 내려주진 않는다. 다만, 점차 진화적으로 발전해온 개념이며(나는 이걸 어느날 갑자기 튀어나온 개념이 아니라고 해석했다.), 캡슐화, 은닉화, 상속과 합성이 가능하며, 다형성을 갖는 프로그래밍의 한 방식이라고 말한다.

먼저, `캡슐화`와 `은닉화`를 얘기하자면,

객체는 기본적으로 데이터와 행동이 함께 정의돼있다. 단일 객체로서, 데이터와 행동을 함께 포장(**캡슐화!**)한 것이다. 

여기서 사용자는(개발자일 수도 있고, 정말 제품을 사용하는 고객일 수도 있고. 주로 개발자를 가리킨다.) 

나는 이런 방식이 verilog hdl로 하드웨어를 설계할 때, '뭐든지 모듈로 보는 방식'과 유사하다고 생각했다. 인풋과 아웃풋이라는, 외부에서 접근가능한 방식만이 겉으로 드러날 뿐이고, 내부 구조는 모른다. 그냥 어떤 인풋을 넣으면, 어떤 아웃풋이 나오는 커다란 블랙박스(모듈)일 뿐이다.

이런 모듈성이 굉장히 중요한 이유가, 객체지향은 개발 단계에서의 편의를 위해 기존 절차지향의 최적화를 포기한 trade-off 이기 때문이다. (라고 제미나이가 표현했다.)

사람의 입장에서 절차지향적으로 대규모 코드를 짜고 나면, 여기저기 왔다갔다 읽으려고 하니 이해하기가 어렵지만, 어떤 추상적인 기능을 하는 객체로서 (모듈) 정의하고 나면, 훨씬 이해하기 쉬워진다. 

이런 방식(추상적인 기능과 IF 부분만 약속하고, 구현은 맡기는 것)은 이미 곳곳에서 녹아있던 방식같다. 
- OS들이 제공하는 API를 통해 구현한 다양한 컴파일러들의 API 함수라던지, 
- 당장 자동차만 생각해도 우리는 내부구현이 어떻게 돼있는지 모른다. 다만, 계기판과, 기어봉, 핸들과 시동(키 또는 버튼) 등으로 자동차를 조작할 뿐이다. 

이 객체에 대해 내부 동작(구현부)는 알지 못한채로, 외부로 드러나있는 인터페이스(public으로 지정된 행동들)를 통해 데이터에 접근할 수 있다.(**은닉화!**) 
> 여기서 인터페이스는 자동차의 기어봉이나, 핸들, 계기판 등을 생각하면 된다. 자동차 차체 내부에서 동작하는 복잡한 기계 장치들의 실시간 상황을 살피거나 조작할 수 있는 부분들이다.

책에서는 "어떤 객체도 다른 객체의 속성을 직접 변경할 수 없다."고 말한다. 만일 은닉화를 위배한다면, (다른 객체가 다른 객체의 속성을 직접 변경한다면) 객체의 성질을 잃어버리고 '주체(subject)'가 돼버릴 것이다. 보통은 setter와 getter로 속성을 변경하고 값을 가져온다고 한다. 이런 방식이 중요한 게, 특히 보안과 테스트 및 유지보수에 꼭 필요하다. 즉, **문제가 생겼을 때, 속성을 변경할 가능성이 있는 모든 코드를 추적할 필요가 없어진다.**

위와 같은 이유가 있어서, 클래스를 설계할 때, 공개 I/F를 설정하고 (반환 값이나 사용법 등), 감출 구현부를 정하는 일이 중요하다고 한다.

생각해보면, 캡스톤 디자인으로 프로그램을 짤 때에도, 하나의 모듈(클래스)에 대한 I/F를 미리 설정해놓지 않아 애먹었던 적이 많다. 

구성원들이 I/F의 반환자를 모르거나, 심지어는 존재조차도 몰랐던 적이 있다. 

미리 I/F에 관한 계약을 위해, interface라는 개념이 생긴 것도 무리가 아닌 것 같다. (interface가 어느정도 다중 상속을 대체하는 기능이 있다고도 들었다.)

추가로, 캡슐화는 일종의 Wrapper로서 쓸 수 있기 때문에, legacy 코드들을 다루는 데에도 쓰인다고 한다.

그 다음으로, `상속`과 `합성`이 있다.

상속은 부모 클래스로부터 자식 클래스가 속성과 행위를 물려받는 시스템이다. (상속을 사용하면 알아서 자식 클래스에서도 부모 클래스의 속성과 행위를 쓸 수 있게 된다. 다양한 언어들에서 extends 등의 키워드를 쓴다.) 객체지향을 소개할 때는 보통 'is-a'관계를 통해 상속을 구분할 수 있다고 소개한다. 
> 예를 들면, 골든리트리버 is Dog이고, Dog is Mammal(포유류)이다. 
> - 따라서, 골든리트리버 클래스는 Dog 클래스의 자식클래스이고, (상속받았고) 
> - Dog 클래스는 Mammal 클래스를 상속받았다.

합성은 다른 객체들로 이루어진 하나의 객체를 만드는 방법이다. 즉, 객체에 다른 객체가 들어있는 형태라고 봐도 되겠다.
> 예를 들면, 컴퓨터라는 객체는 그래픽 카드, 키보드, 마우스 등의 객체로 이루어졌다.
> - 그래픽 카드, 키보드 등을 따로 떼어 손에 쥘 수 있고, 각 객체는 별도의 기능을 한다.

보통 'has-a'관계로 나타낼 수 있으면, 합성이라고 한다.
> 예를 들어, Car 클래스는 Engine 클래스와 Door 클래스 등으로 합성된 클래스이다.
> - Engine is a Car (x). 따라서 상속은 아니다.
> - A Car has a Engine (o). Car은 합성으로 이루어져있다.

나중에 다시 언급하겠지만, 제미나이도 그렇고, 합성을 대부분 선호한다고 한다. 하지만 저자는, 분명히 어느 하나가 좋다/나쁘다를 떠나서 상황에 맞게 잘 쓸 줄 아는 유연한 사고를 강조한다.


<br><br>


### 객체지향 프로그래밍을 하는 법.

저자는 전통적인 구조적 프로그래밍(절차지향)과 객체지향 프로그래밍은 상호 배타적이지 않다고 말한다. 즉, 구조적인 프로그래밍의 루프나 if문등이 반드시 포함되므로, 두 개의 방식은 서로 공존할 수 밖에 없다는 것이다.
> 이를테면 어떤 클래스 안의 한 메서드는, if나 루프문이 포함돼있다. 

그러면서, 중요한 몇 가지를 나열한다.

1. 더욱 추상적으로 생각하기.
    - 추상화가 높아질 수록, 구현부에 의존성이 멀어지기 때문에 재사용 가능성이 높아진다. 다만, 그 적절선은 고민해 봐야한다.
        > 예를 들면, 공항가는 택시라는 클래스로부터, I/F로 '좌회전', '전진' 등을 제공하는 것보다, "공항으로 가기"와 같은 추상적인 I/F를 제공하는 것이다. 그 구현은 (좌-우-전진-전진 ... ) 자유롭게 맡기고, 때에 따라 다르게 할 수 있겠다.
2. 사용자에게 가능한 한 I/F를 적게 제공하기.
    - 사용자가 몰라야 할 것을 구분한다. 필수적이지 않은 데이터를 숨기는데, 이는 다른 객체가 함부로 해당 객체 내의 데이터에 접근할 수 없게 함으로써, 책임을 좁힐 수 있고, 또 동시에 보안도 챙길 수 있기 때문이다.
3. 인터페이스를 그대로 두고, 구현부를 변경해도 문제 없도록 한다. 
    - 즉, 이 I/F를 쓰는 사람들은 유지/보수 후에도 여전히 해당 I/F 대로만 쓰면 된다. 전체 코드를 고칠 필요가 없다! 
    - 이러면 유지/보수/관리가 쉽겠다.
    - 래퍼(Wrapper)도 넣을 수 있을 것 같다. 구조적 프로그래밍의 요소(반복, 순서, 조건 등)을 ㄴ허거나, 혹은 특정 플랫폼에만 실행되는 코드를 래퍼로 감싸 실행시키거나,(내부 구현은 해당 프로그램에 맞추지만, I/F만큼은 기존에 쓰던, 혹은 사용할 I/F에 맞추면 된다. 다른 사람이 만든 코드 역시 마찬가지이다.) 하는 식이다.

그리고 저자는 처음에는 아예 클래스에서 I/F를 제공하지 않고 시작하는 방식을 추천한다. 결국 개발이 진행됨에 따라, 사용자가 어떤 I/F가 필요하다고 요청할 것이고, 그때마다 추가하면 된다는 것이다.
> 생각해보니 나도 이번 캡스톤 디자인을 하면서, PromptBuffer라는 클래스에서 계속해서 필요한 메서드를 추가하게 됐던 것 같다. 처음엔 2개에서 시작했던 I/F가, 상황에 따라 특정 데이터를 반환시켜야 될 필요가 있다보니 최종적으로 4개까지 늘어났다.

+ 그 밖에 생성자에서 초기화의 중요성을 (자동으로 채워지는 값을 믿지 말기. 사람은 실수를 하기 때문에 예상치 못하게 들어있는 값으로 낭패를 볼 수 있다.) 강조하거나, 오류를 try-catch 등의 다양한 방법들로 처리하는 법을 소개한다.

<br><br>


### 객체지향 설계

저자는 진정한 방법론이 하나로 정해져있지 않다고 했다. 다만, 가장 중요한 문제는 "메서드 사용법을 어떻게 설계했는지"라고 한다.

또, 좋은 설계의 요소 중 하나는, "자신과 조직이 편안하게 느끼고 이를 고수, 계속 개선하는 과정을 찾는 것"이라고 했다. 결국 협업을 하는 것이기 때문에, 구성원들이 공통적으로 인정하는 부분을 찾아야 하는 것 같다. 

일반적인 방법론에 대해서도 간략히 소개했다.

1. 적절한 분석을 수행한다.
2. system을 설명하는 작업 명세서를 개발한다.
    - 시스템을 설명하는 문서로 문단형식으로 작성됐다.
3. 이 작업명세서로부터 요구사항을 수집한다. 
    - 소요제기서(요구사항 명세서)를 작성한다. 충분히 구체적으로 쓴다. 글, 머리, 기호, 항목 등으로 이루어져있다.
4. 사용자 I/F용 프로토타입을 만든다.
    - 모든 기능을 구현하는 것보다는, 비즈니스 로직 없이, 사용자가 쓸 I/F를 유저 입장에서 시뮬레이션만 해본다.
5. 클래스를 식별한다. (필요한 클래스들을 어느정도 만들어둔다.)
6. 각 클래스 역할을 결정한다.
    - 5번과 6번은 같이 진행하는 것 같다.
    - 6번의 경우에서, 저자는 소요제기서에 나오는 모든 **명사**들을 강조표시해서 클래스로 추가하면 높은 확률로 성공한다고 했다.
7. 다양한 클래스가 상호작용하는 방식을 결정한다.
8. 만들고자 하는 시스템을 설명한는 고급 모델을 구성한다.

이러한 과정 중에 채택할 실제 설계 방법론들은 다양하다고 했다.

폭포수 모델은, 설계->구현->배포의 단계로 나누고, 각 단계는 이후 단계보다 수정비용이 훨씬 저렴하기에, 이론상 각 단계마다 철저히 완성한 후, 다음 단계로 나가는 모델이다. 현실적으로는 불가능하지만, 분명히 전 단계에서 수정하는 것이 싸기 때문에, 목표는 이해할만 하다고 강조한다.

현대 모델은 프로토타이핑 부터 애자일까지 다양하다고 했다. 

하지만 결국 객체지향 설계는 '반복'이라고 책 거의 전반에 걸쳐 강조한다. 최대한 줄인 I/F부터 시작해서, '사용자'(여기서 사용자는 개발자를 의미했다.)가 요구하는 바를 이루기 위해 추가하고, 혹은 제거하는 과정이었다. 처음부터 완벽하게 만들 수 없기 때문이다.
> 얼마전에 PCB 특강을 들었는데, 이 분야에서도 역시나, 강사님이 결국 원하는 스펙을 갖출 때 까지 '수정(디버깅 포함)'이 가장 시간을 많이 잡아먹는다고 했다. 엔지니어는 하는 일이 그런 거라고 한다.



